use ratatui::{
    buffer::Buffer,
    layout::Rect,
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph, Widget as RatatuiWidget},
};
use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
use tui_textarea::TextArea;
use crate::config::PaletteColor;

/// Mode for the color form (Create new or Edit existing)
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum FormMode {
    Create,
    Edit { original_name: [char; 64], original_len: usize },
}

/// Form for creating/editing color palette entries
pub struct ColorForm {
    // Form fields (TextArea)
    name: TextArea<'static>,
    color: TextArea<'static>,
    category: TextArea<'static>,
    favorite: bool,

    // UI state
    focused_field: usize, // 0=name, 1=color, 2=category, 3=favorite, 4=save, 5=delete, 6=cancel
    mode: FormMode,

    // Popup position (for dragging)
    pub popup_x: u16,
    pub popup_y: u16,
    pub is_dragging: bool,
    pub drag_offset_x: u16,
    pub drag_offset_y: u16,
}

impl ColorForm {
    /// Create a new empty form for adding a color
    pub fn new_create() -> Self {
        let mut name = TextArea::default();
        name.set_placeholder_text("e.g., Primary Blue");

        let mut color = TextArea::default();
        color.set_placeholder_text("e.g., #0066cc");

        let mut category = TextArea::default();
        category.set_placeholder_text("e.g., blues, reds, greens");

        Self {
            name,
            color,
            category,
            favorite: false,
            focused_field: 0,
            mode: FormMode::Create,
            popup_x: 20,
            popup_y: 5,
            is_dragging: false,
            drag_offset_x: 0,
            drag_offset_y: 0,
        }
    }

    /// Create a form for editing an existing color
    pub fn new_edit(palette_color: &PaletteColor) -> Self {
        let mut original_name = ['\0'; 64];
        let original_len = palette_color.name.len().min(64);
        for (i, ch) in palette_color.name.chars().take(64).enumerate() {
            original_name[i] = ch;
        }

        let mut name = TextArea::default();
        name.insert_str(&palette_color.name);

        let mut color = TextArea::default();
        color.insert_str(&palette_color.color);

        let mut category = TextArea::default();
        category.insert_str(&palette_color.category);

        Self {
            name,
            color,
            category,
            favorite: palette_color.favorite,
            focused_field: 0,
            mode: FormMode::Edit { original_name, original_len },
            popup_x: 20,
            popup_y: 5,
            is_dragging: false,
            drag_offset_x: 0,
            drag_offset_y: 0,
        }
    }

    pub fn handle_input(&mut self, key_event: KeyEvent) -> Option<FormAction> {
        if key_event.modifiers.contains(KeyModifiers::CONTROL) {
            return None;
        }

        match key_event.code {
            KeyCode::Esc => {
                return Some(FormAction::Cancel);
            }
            KeyCode::BackTab => {
                self.previous_field();
                return None;
            }
            KeyCode::Tab => {
                self.next_field();
                return None;
            }
            KeyCode::Enter => {
                if self.focused_field == 4 {
                    // Save button
                    return self.validate_and_save();
                } else if self.focused_field == 5 && matches!(self.mode, FormMode::Edit { .. }) {
                    // Delete button (only in edit mode)
                    return Some(FormAction::Delete);
                } else if self.focused_field == 6 || (self.focused_field == 5 && matches!(self.mode, FormMode::Create)) {
                    // Cancel button
                    return Some(FormAction::Cancel);
                } else if self.focused_field == 3 {
                    // Toggle favorite checkbox
                    self.favorite = !self.favorite;
                    return None;
                }
            }
            KeyCode::Char(' ') if self.focused_field == 3 => {
                // Space toggles favorite
                self.favorite = !self.favorite;
                return None;
            }
            _ => {
                // Convert crossterm KeyEvent to ratatui KeyEvent for TextArea
                use ratatui::crossterm::event as rt_event;

                // Convert KeyCode
                let rt_code = match key_event.code {
                    KeyCode::Backspace => rt_event::KeyCode::Backspace,
                    KeyCode::Enter => rt_event::KeyCode::Enter,
                    KeyCode::Left => rt_event::KeyCode::Left,
                    KeyCode::Right => rt_event::KeyCode::Right,
                    KeyCode::Up => rt_event::KeyCode::Up,
                    KeyCode::Down => rt_event::KeyCode::Down,
                    KeyCode::Home => rt_event::KeyCode::Home,
                    KeyCode::End => rt_event::KeyCode::End,
                    KeyCode::PageUp => rt_event::KeyCode::PageUp,
                    KeyCode::PageDown => rt_event::KeyCode::PageDown,
                    KeyCode::Tab => rt_event::KeyCode::Tab,
                    KeyCode::BackTab => rt_event::KeyCode::BackTab,
                    KeyCode::Delete => rt_event::KeyCode::Delete,
                    KeyCode::Insert => rt_event::KeyCode::Insert,
                    KeyCode::F(n) => rt_event::KeyCode::F(n),
                    KeyCode::Char(c) => rt_event::KeyCode::Char(c),
                    KeyCode::Null => rt_event::KeyCode::Null,
                    KeyCode::Esc => rt_event::KeyCode::Esc,
                    _ => rt_event::KeyCode::Null,
                };

                // Convert KeyModifiers
                let mut rt_modifiers = rt_event::KeyModifiers::empty();
                if key_event.modifiers.contains(KeyModifiers::SHIFT) {
                    rt_modifiers |= rt_event::KeyModifiers::SHIFT;
                }
                if key_event.modifiers.contains(KeyModifiers::CONTROL) {
                    rt_modifiers |= rt_event::KeyModifiers::CONTROL;
                }
                if key_event.modifiers.contains(KeyModifiers::ALT) {
                    rt_modifiers |= rt_event::KeyModifiers::ALT;
                }

                let rt_key = rt_event::KeyEvent {
                    code: rt_code,
                    modifiers: rt_modifiers,
                    kind: rt_event::KeyEventKind::Press,
                    state: rt_event::KeyEventState::empty(),
                };

                // Pass to the focused textarea
                match self.focused_field {
                    0 => { self.name.input(rt_key); }
                    1 => { self.category.input(rt_key); }
                    2 => { self.color.input(rt_key); }
                    _ => {}
                }
            }
        }

        None
    }

    fn next_field(&mut self) {
        self.focused_field = match self.focused_field {
            0 => 1,  // name -> color
            1 => 2,  // color -> category
            2 => 3,  // category -> favorite
            3 => 4,  // favorite -> save
            4 => {
                if matches!(self.mode, FormMode::Edit { .. }) {
                    5  // save -> delete (edit mode only)
                } else {
                    5  // save -> cancel (create mode)
                }
            }
            5 => {
                if matches!(self.mode, FormMode::Edit { .. }) {
                    6  // delete -> cancel (edit mode)
                } else {
                    0  // cancel -> name (create mode)
                }
            }
            6 => 0,  // cancel -> name (edit mode)
            _ => 0,
        };
    }

    fn previous_field(&mut self) {
        self.focused_field = match self.focused_field {
            0 => {
                if matches!(self.mode, FormMode::Edit { .. }) {
                    6  // name -> cancel (edit mode)
                } else {
                    5  // name -> cancel (create mode)
                }
            }
            1 => 0,  // color -> name
            2 => 1,  // category -> color
            3 => 2,  // favorite -> category
            4 => 3,  // save -> favorite
            5 => {
                if matches!(self.mode, FormMode::Edit { .. }) {
                    4  // delete -> save (edit mode)
                } else {
                    4  // cancel -> save (create mode)
                }
            }
            6 => 5,  // cancel -> delete (edit mode only)
            _ => 0,
        };
    }

    fn validate_and_save(&self) -> Option<FormAction> {
        let name_val = self.name.lines()[0].to_string();
        let color_val = self.color.lines()[0].to_string();
        let category_val = self.category.lines()[0].to_string();

        // Validate name
        if name_val.trim().is_empty() {
            return Some(FormAction::Error("Name cannot be empty".to_string()));
        }

        // Validate color (must be hex format)
        if !color_val.starts_with('#') || color_val.len() != 7 {
            return Some(FormAction::Error("Color must be in format #RRGGBB".to_string()));
        }

        // Validate hex digits
        if !color_val[1..].chars().all(|c| c.is_ascii_hexdigit()) {
            return Some(FormAction::Error("Color must contain valid hex digits (0-9, A-F)".to_string()));
        }

        // Validate category
        if category_val.trim().is_empty() {
            return Some(FormAction::Error("Category cannot be empty".to_string()));
        }

        let original_name = if let FormMode::Edit { original_name, original_len } = self.mode {
            Some(original_name.iter().take(original_len).collect::<String>())
        } else {
            None
        };

        Some(FormAction::Save {
            color: PaletteColor {
                name: name_val.trim().to_string(),
                color: color_val.trim().to_uppercase(),
                category: category_val.trim().to_lowercase(),
                favorite: self.favorite,
            },
            original_name,
        })
    }

    /// Handle mouse events for dragging the popup
    pub fn handle_mouse(&mut self, mouse_col: u16, mouse_row: u16, mouse_down: bool, area: Rect) -> bool {
        let popup_width = 70;

        // Check if mouse is on title bar
        let on_title_bar = mouse_row == self.popup_y
            && mouse_col > self.popup_x
            && mouse_col < self.popup_x + popup_width - 1;

        if mouse_down && on_title_bar && !self.is_dragging {
            // Start dragging
            self.is_dragging = true;
            self.drag_offset_x = mouse_col.saturating_sub(self.popup_x);
            self.drag_offset_y = mouse_row.saturating_sub(self.popup_y);
            return true;
        }

        if self.is_dragging {
            if mouse_down {
                // Continue dragging
                self.popup_x = mouse_col.saturating_sub(self.drag_offset_x);
                self.popup_y = mouse_row.saturating_sub(self.drag_offset_y);

                // Keep popup within bounds
                if self.popup_x + popup_width > area.width {
                    self.popup_x = area.width.saturating_sub(popup_width);
                }
                if self.popup_y + 20 > area.height {
                    self.popup_y = area.height.saturating_sub(20);
                }

                return true;
            } else {
                // Stop dragging
                self.is_dragging = false;
                return true;
            }
        }

        false
    }

    pub fn render(&mut self, area: Rect, buf: &mut Buffer) {
        let popup_width = 70;
        let popup_height = 20;

        // Draw black background
        for row in self.popup_y..self.popup_y + popup_height {
            for col in self.popup_x..self.popup_x + popup_width {
                if col < area.width && row < area.height {
                    buf.set_string(col, row, " ", Style::default().bg(Color::Black));
                }
            }
        }

        // Draw border
        let border_style = Style::default().fg(Color::Cyan);

        // Top border
        let top = format!("┌{}┐", "─".repeat(popup_width as usize - 2));
        buf.set_string(self.popup_x, self.popup_y, &top, border_style);

        // Title
        let title = match self.mode {
            FormMode::Create => " Add Color ",
            FormMode::Edit { .. } => " Edit Color ",
        };
        buf.set_string(self.popup_x + 2, self.popup_y, title, border_style.add_modifier(Modifier::BOLD));

        // Side borders
        for i in 1..popup_height - 1 {
            buf.set_string(self.popup_x, self.popup_y + i, "│", border_style);
            buf.set_string(self.popup_x + popup_width - 1, self.popup_y + i, "│", border_style);
        }

        // Bottom border
        let bottom = format!("└{}┘", "─".repeat(popup_width as usize - 2));
        buf.set_string(self.popup_x, self.popup_y + popup_height - 1, &bottom, border_style);

        // Get color value for preview
        let color_val = self.color.lines()[0].to_string();

        // Render fields
        let mut y = self.popup_y + 2;
        let focused = self.focused_field;

        // Name field
        Self::render_text_field(focused, 0, "Name:", &mut self.name, self.popup_x + 2, y, popup_width - 4, buf);
        y += 3;

        // Category field
        Self::render_text_field(focused, 1, "Category:", &mut self.category, self.popup_x + 2, y, popup_width - 4, buf);
        y += 4;

        // Color field with preview
        Self::render_text_field(focused, 2, "Color:", &mut self.color, self.popup_x + 2, y, popup_width - 12, buf);
        self.render_color_preview(&color_val, self.popup_x + popup_width - 8, y + 1, buf);
        y += 3;

        // Favorite checkbox
        self.render_checkbox(3, "Favorite:", self.favorite, self.popup_x + 2, y, buf);
        y += 3;

        // Buttons
        self.render_buttons(self.popup_x + 2, y, buf);
        y += 2;

        // Status bar
        let status = "Tab/Shift+Tab: Navigate | Enter: Select | Esc: Cancel";
        buf.set_string(self.popup_x + 2, y, status, Style::default().fg(Color::Gray));
    }

    fn render_text_field(
        focused_field: usize,
        field_id: usize,
        label: &str,
        textarea: &mut TextArea,
        x: u16,
        y: u16,
        width: u16,
        buf: &mut Buffer,
    ) {
        // Label
        let label_span = Span::styled(label, Style::default().fg(Color::White));
        let label_area = Rect { x, y, width: 14, height: 1 };
        let label_para = Paragraph::new(Line::from(label_span));
        RatatuiWidget::render(label_para, label_area, buf);

        // Set style based on focus
        let border_style = if focused_field == field_id {
            Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)
        } else {
            Style::default().fg(Color::White)
        };

        // Set text style without any modifiers - must be plain with no underline
        textarea.set_style(Style::default().fg(Color::White));
        textarea.set_cursor_style(Style::default().bg(Color::Yellow));
        textarea.set_cursor_line_style(Style::default());

        // Set placeholder style to match (no underline)
        textarea.set_placeholder_style(Style::default().fg(Color::DarkGray));

        // Input area
        let input_area = Rect {
            x: x + 14,
            y,
            width: width.saturating_sub(14),
            height: 3,
        };

        // Set border and style
        textarea.set_block(
            Block::default()
                .borders(Borders::ALL)
                .border_style(border_style)
        );

        RatatuiWidget::render(&*textarea, input_area, buf);
    }

    fn render_checkbox(&self, field_id: usize, label: &str, checked: bool, x: u16, y: u16, buf: &mut Buffer) {
        let checkbox_text = if checked { "[X]" } else { "[ ]" };
        let checkbox_style = if self.focused_field == field_id {
            Style::default().fg(Color::Black).bg(Color::Yellow)
        } else {
            Style::default().fg(Color::White)
        };

        buf.set_string(x, y, label, Style::default().fg(Color::White));
        buf.set_string(x + label.len() as u16 + 1, y, checkbox_text, checkbox_style);
    }

    fn render_buttons(&self, x: u16, y: u16, buf: &mut Buffer) {
        let save_style = if self.focused_field == 4 {
            Style::default().fg(Color::Black).bg(Color::Green)
        } else {
            Style::default().fg(Color::Green)
        };
        buf.set_string(x, y, "[ Save ]", save_style);

        if matches!(self.mode, FormMode::Edit { .. }) {
            let delete_style = if self.focused_field == 5 {
                Style::default().fg(Color::Black).bg(Color::Red)
            } else {
                Style::default().fg(Color::Red)
            };
            buf.set_string(x + 15, y, "[ Delete ]", delete_style);
        }

        let cancel_col = if matches!(self.mode, FormMode::Edit { .. }) { x + 33 } else { x + 15 };
        let cancel_field = if matches!(self.mode, FormMode::Edit { .. }) { 6 } else { 5 };
        let cancel_style = if self.focused_field == cancel_field {
            Style::default().fg(Color::Black).bg(Color::White)
        } else {
            Style::default().fg(Color::Gray)
        };
        buf.set_string(cancel_col, y, "[ Cancel ]", cancel_style);
    }

    fn render_color_preview(&self, color_str: &str, x: u16, y: u16, buf: &mut Buffer) {
        if !color_str.is_empty() && self.is_valid_hex_color(color_str) {
            if let Some(color) = self.parse_color(color_str) {
                let preview = "    ";
                buf.set_string(x, y, preview, Style::default().bg(color));
            }
        }
    }

    fn is_valid_hex_color(&self, color: &str) -> bool {
        if !color.starts_with('#') || color.len() != 7 {
            return false;
        }
        color[1..].chars().all(|c| c.is_ascii_hexdigit())
    }

    fn parse_color(&self, hex: &str) -> Option<Color> {
        if hex.len() != 7 || !hex.starts_with('#') {
            return None;
        }
        let r = u8::from_str_radix(&hex[1..3], 16).ok()?;
        let g = u8::from_str_radix(&hex[3..5], 16).ok()?;
        let b = u8::from_str_radix(&hex[5..7], 16).ok()?;
        Some(Color::Rgb(r, g, b))
    }

    /// Get the original name if in edit mode
    pub fn get_original_name(&self) -> Option<String> {
        match self.mode {
            FormMode::Edit { original_name, original_len } => {
                Some(original_name.iter().take(original_len).collect())
            }
            FormMode::Create => None,
        }
    }
}

#[derive(Debug, Clone)]
pub enum FormAction {
    Save { color: PaletteColor, original_name: Option<String> },
    Delete,
    Cancel,
    Error(String),
}
