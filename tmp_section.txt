        // Build the top stack: start with row 0 statics; each next row keeps only statics overlapping with previous row's stack spans; stop on gaps
        use std::collections::HashSet as _HashSetAlias; // avoid shadowing
        let mut stack_indices: _HashSetAlias<usize> = _HashSetAlias::new();
        let mut prev_spans: Vec<(u16, u16, usize)> = statics_by_row.get(&0).cloned().unwrap_or_default();
        for (_, i) in prev_spans.iter().map(|(_, _, idx)| ((), *idx)) { stack_indices.insert(i); }

        if !prev_spans.is_empty() {
            for (row, spans) in statics_by_row.iter().filter(|(r, _)| **r > 0) {
                // Only allow contiguous rows: if this row is not exactly prev_row + 1, break the chain
                // Compute expected next row as last processed row + 1 by tracking last_row separately
            }
        }

        // Implement contiguous rows with tracking
        let mut current_row_opt = Some(0u16);
        let mut last_spans = prev_spans;
        while let Some(current_row) = current_row_opt {
            let next_row = current_row.saturating_add(1);
            if let Some(candidates) = statics_by_row.get(&next_row) {
                let mut next_spans: Vec<(u16, u16, usize)> = Vec::new();
                for (s, e, idx) in candidates.iter().copied() {
                    // overlap with any last_spans
                    let overlaps = last_spans.iter().any(|(ps, pe, _)| s < *pe && e > *ps);
                    if overlaps {
                        next_spans.push((s, e, idx));
                        stack_indices.insert(idx);
                    }
                }
                if next_spans.is_empty() {
                    break;
                } else {
                    last_spans = next_spans;
                    current_row_opt = Some(next_row);
                }
            } else {
                break;
            }
        }

        // Apply anchoring: command_input to bottom; top-stack statics remain at their baseline rows; others shift by delta
        for (i, window) in self.layout.windows.iter_mut().enumerate() {
            if window.widget_type == "command_input" {
                let old_row = window.row;
                window.row = new_height.saturating_sub(window.rows);
                tracing::debug!("Command input anchored: old_row={}, new_row={}", old_row, window.row);
                continue;
            }
            if static_both.contains(&window.name) || static_height.contains(&window.name) {
                let baseline_row = baseline_rows[i];
                if stack_indices.contains(&i) {
                    window.row = baseline_row.min(new_height.saturating_sub(window.rows));
                } else {
                    window.row = (baseline_row as i32 + height_delta).max(0) as u16;
                }
            }
        }
    }

    // Width-only proportional pass extracted for readability
    fn apply_width_resize(
        &mut self,
        width_delta: i32,
        static_both: &std::collections::HashSet<String>,
    ) {
        use std::collections::HashSet;
        if width_delta == 0 { return; }

        tracing::debug!("--- WIDTH SCALING (extracted) ---");

        let mut width_applied = HashSet::new();
        let max_row = self.layout.windows.iter().map(|w| w.row + w.rows).max().unwrap_or(0);
        for current_row in 0..max_row {
            let mut widgets_at_row: Vec<(String, String, u16, u16, u16, u16)> = Vec::new();
            for window in &self.layout.windows {
                if width_applied.contains(&window.name) { continue; }
                if current_row >= window.row && current_row < window.row + window.rows {
                    widgets_at_row.push((window.name.clone(), window.widget_type.clone(), window.row, window.col, window.rows, window.cols));
                }
            }
            if widgets_at_row.is_empty() { continue; }
            widgets_at_row.sort_by_key(|(_, _, _, col, _, _)| *col);

