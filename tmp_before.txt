    fn apply_proportional_resize(&mut self, width_delta: i32, height_delta: i32) {
    /// Apply proportional resizing to layout based on delta

    }
        }
            }
                }
                    debug!("Failed to access clipboard: {}", e);
                Err(e) => {
                }
                    }
                        debug!("Copied {} characters to clipboard", selected_text.len());
                    } else {
                        debug!("Failed to copy to clipboard: {}", e);
                    if let Err(e) = clipboard.set_text(&selected_text) {
                Ok(mut clipboard) => {
            match arboard::Clipboard::new() {
        if !selected_text.is_empty() {
        // Copy to clipboard

        }
            }
                selected_text.push('\n');
            if line_idx < end.line {
            // Add newline except for last line

            }
                col_offset = segment_end;

                }
                    }
                        selected_text.push_str(&selected_chars);
                        let selected_chars: String = chars[seg_start..seg_end.min(chars.len())].iter().collect();
                        let chars: Vec<char> = segment.text.chars().collect();
                    if seg_start < segment.text.len() {

                    let seg_end = (end_col.saturating_sub(col_offset)).min(segment.text.len());
                    let seg_start = start_col.saturating_sub(col_offset);
                    // This segment overlaps with selection
                if segment_end > start_col {

                }
                    break;
                if col_offset >= end_col {

                let segment_end = col_offset + segment.text.len();
            for segment in &line.segments {
            let mut col_offset = 0;
            // Extract text from the line

            };
                (0, usize::MAX)
                // Middle lines - full line
            } else {
                (0, end.col)
                // Last line - from beginning to end_col
            } else if line_idx == end.line {
                (start.col, usize::MAX)
                // First line - from start_col to end
            } else if line_idx == start.line {
                (start.col, end.col)
                // Same line - use both bounds
            let (start_col, end_col) = if line_idx == start.line && line_idx == end.line {
            // Determine which columns to include from this line

            let line = &lines[line_idx];

            }
                break;
            if line_idx >= lines.len() {
        for line_idx in start.line..=end.line.min(lines.len().saturating_sub(1)) {

        let lines = widget.get_lines();
        // Get the visible lines from the text window

        let mut selected_text = String::new();
        let (start, end) = selection.normalized_range();
        // Extract selected text

        let widget = text_window;

        };
            _ => return,
            }
                }
                    None => return,
                    Some(active_window) => active_window,
                match tabbed.get_active_window_mut() {
                // For tabbed windows, get the active tab's text window
            Some(Widget::Tabbed(tabbed)) => {
            Some(Widget::Text(text_window)) => text_window,
        let text_window = match self.window_manager.get_window(window_name) {
        // Get the text window (either standalone or from active tab)

        let window_name = &window_names[selection.start.window_index];

        }
            return;
        if selection.start.window_index >= window_names.len() {
        let window_names = self.window_manager.get_window_names();
        // Get the window being selected

        };
            _ => return,
            Some(s) if s.active => s,
        let selection = match &self.selection_state {
    fn copy_selection_to_clipboard(&mut self, window_layouts: &HashMap<String, ratatui::layout::Rect>) {
    /// Copy the currently selected text to clipboard

    }
        None

        }
            }
                }
                    }
                        }
                            _ => {}
                            }
                                return Some((idx, rel_row, rel_col));

                                }
                                    _ => {}
                                    }
                                        }
                                            return Some((idx, absolute_line, rel_col));
                                            let absolute_line = active_window.relative_row_to_absolute_line(adjusted_row, visible_height);

                                                .saturating_sub(inner_border_total as u16) as usize;
                                                .saturating_sub(tab_bar_height as u16)
                                                .saturating_sub(outer_border_height as u16)
                                            let visible_height = rect.height
                                            let inner_border_total = if active_window.has_border() { 2 } else { 0 };
                                            let outer_border_height = if has_border { 2 } else { 0 };
                                            // Calculate visible height: total height - outer borders - tab bar - inner borders

                                            let adjusted_row = rel_row.saturating_sub(offset);

                                            offset += inner_border_height; // Inner TextWindow border
                                            }
                                                offset += tab_bar_height; // Tab bar
                                            if tab_bar_at_top {
                                            let mut offset = 0;
                                            // Structure: [outer border (has_border)] + [tab bar] + [inner border] + [content]
                                            // Calculate total offset from rel_row (which is after outer border)

                                            let inner_border_height = if active_window.has_border() { 1 } else { 0 };
                                            // Account for inner TextWindow border (always present)

                                            let tab_bar_height: usize = 1;
                                            // Account for tab bar height (usually 1 row at top or bottom)

                                                .unwrap_or(true); // default to top
                                                .map(|pos| pos == "top")
                                                .and_then(|w| w.tab_bar_position.as_ref())
                                            let tab_bar_at_top = self.layout.windows.get(idx)
                                            // Get tab bar position from config
                                        if let Some(active_window) = tabbed.get_active_window() {
                                        // For tabbed windows, get the active tab's text window
                                    Widget::Tabbed(tabbed) => {
                                    }
                                        return Some((idx, absolute_line, rel_col));
                                        let absolute_line = text_window.relative_row_to_absolute_line(rel_row, visible_height);
                                        };
                                            rect.height as usize
                                        } else {
                                            rect.height.saturating_sub(2) as usize
                                        let visible_height = if has_border {
                                    Widget::Text(text_window) => {
                                match widget {
                                // Convert relative row to absolute line index (accounting for scrolling)

                                };
                                    )
                                        (mouse_row - rect.y) as usize,
                                        (mouse_col - rect.x) as usize,
                                    (
                                } else {
                                    )
                                        (mouse_row.saturating_sub(rect.y + 1)) as usize,
                                        (mouse_col.saturating_sub(rect.x + 1)) as usize,
                                    (
                                    // Border takes 1 cell on each side
                                let (rel_col, rel_row) = if has_border {

                                    .unwrap_or(false);
                                    .map(|w| w.show_border)
                                let has_border = self.layout.windows.get(idx)
                                // Account for border (if present)
                                // Convert to window-relative coordinates
                            Widget::Text(_) | Widget::Tabbed(_) => {
                        match widget {
                    if let Some(widget) = self.window_manager.get_window_const(name) {
                    // Only handle text windows and tabbed windows for selection
                {
                    && mouse_row < rect.y + rect.height
                    && mouse_row >= rect.y
                    && mouse_col < rect.x + rect.width
                if mouse_col >= rect.x
                // Check if mouse is within window bounds
            if let Some(rect) = window_layouts.get(name) {
        for (idx, name) in window_names.iter().enumerate() {

        let window_names = self.window_manager.get_window_names();
    ) -> Option<(usize, usize, usize)> {
        window_layouts: &HashMap<String, ratatui::layout::Rect>,
        mouse_row: u16,
        mouse_col: u16,
        &self,
    fn mouse_to_text_position(
    /// Returns None if mouse is not over a text window
    /// Convert mouse screen coordinates to text position (window_idx, line, col)

    }
        None
        }
            }
                }
                    return Some(idx);
                {
                    && mouse_col < rect.x + rect.width.saturating_sub(1)
                    && mouse_col > rect.x
                if mouse_row == rect.y
                // Check if on top border but not in the corners (leave 1 cell margin on each side)

                }
                    }
                        }
                            continue;
                        if !tabbed.has_border() {
                    if let Widget::Tabbed(tabbed) = widget {
                if let Some(widget) = self.window_manager.get_window(name) {
                // (the top row contains tabs, not a title bar)
                // Skip title bar detection for borderless tabbed windows
            if let Some(rect) = window_layouts.get(name) {
        for (idx, name) in window_names.iter().enumerate() {

        let window_names = self.window_manager.get_window_names();
    ) -> Option<usize> {
        window_layouts: &HashMap<String, ratatui::layout::Rect>,
        mouse_row: u16,
        mouse_col: u16,
        &mut self,
    fn check_title_bar(
    /// Returns the window index if on a title bar
    /// Check if the mouse is on a window's title bar (top border, but not corners)

    }
        None

        }
            }
                }
                    return Some((idx, ResizeEdge::Right));
                {
                    && mouse_row < rect.y + rect.height.saturating_sub(1)
                    && mouse_row > rect.y
                if mouse_col == rect.x + rect.width.saturating_sub(1)
                // Check if mouse is on right border (but not top/bottom corners)

                }
                    return Some((idx, ResizeEdge::Left));
                {
                    && mouse_row < rect.y + rect.height.saturating_sub(1)
                    && mouse_row > rect.y
                if mouse_col == rect.x
                // Check if mouse is on left border (but not top/bottom corners to avoid conflict)

                }
                    return Some((idx, ResizeEdge::Bottom));
                {
                    && mouse_col < rect.x + rect.width
                    && mouse_col >= rect.x
                if mouse_row == rect.y + rect.height.saturating_sub(1)
                // Check if mouse is on bottom border (last row of window)

                }
                    // Middle of top border is for moving, not resizing
                    }
                        return Some((idx, ResizeEdge::Top));
                    if mouse_col == rect.x || mouse_col == rect.x + rect.width.saturating_sub(1) {
                if mouse_row == rect.y {
                // Only resize from top edge at the corners (first and last column)
                // Check corners for top edge resizing (leave middle for title bar dragging)
            if let Some(rect) = window_layouts.get(name) {
        for (idx, name) in window_names.iter().enumerate() {

        let window_names = self.window_manager.get_window_names();
    ) -> Option<(usize, ResizeEdge)> {
        window_layouts: &HashMap<String, ratatui::layout::Rect>,
        mouse_row: u16,
        mouse_col: u16,
        &self,
    fn check_resize_border(
    /// Returns (window_index, edge) if on a border
    /// Check if a mouse position is on a resize border

    }
        }
            debug!("Focused window index: {}", self.focused_window_index);
            self.focused_window_index = (self.focused_window_index + 1) % window_count;
        if window_count > 0 {
        let window_count = self.window_manager.get_window_names().len();
    fn cycle_focused_window(&mut self) {
    /// Cycle to next window

    }
        }
            None
        } else {
            self.window_manager.get_window(name)
            let name = &window_names[self.focused_window_index];
        if self.focused_window_index < window_names.len() {
        let window_names = self.window_manager.get_window_names();
    fn get_focused_window(&mut self) -> Option<&mut Widget> {
    /// Get the focused window for scrolling

    }
        }
            }
                }
                    // Other widget types don't support text
                _ => {
                }
                    text_window.finish_line(inner_width);
                Widget::Text(text_window) => {
                }
                    tabbed.finish_line_for_stream(&stream, inner_width);
                    // Finish line for specific tab based on stream
                Widget::Tabbed(tabbed) => {
            match widget {
        if let Some(widget) = self.window_manager.get_window(&window_name) {
        // Get the window

            .unwrap_or_else(|| "main".to_string());
            .cloned()
            .get(&stream)
            .stream_map
        let window_name = self.window_manager
        // Find which window this stream maps to

        let stream = self.current_stream.clone();
    fn finish_current_line(&mut self, inner_width: u16) {
    /// Finish the current line in the appropriate window/tab

    }
        }
            }
                }
                    // Other widget types don't support text
                _ => {
                }
                    text_window.add_text(text);
                Widget::Text(text_window) => {
                }
                    tabbed.add_text_to_stream(&stream, text);
                    // Route to specific tab based on stream
                Widget::Tabbed(tabbed) => {
            match widget {
        if let Some(widget) = self.window_manager.get_window(&window_name) {
        // Get the window

            .unwrap_or_else(|| "main".to_string());
            .cloned()
            .get(&stream)
            .stream_map
        let window_name = self.window_manager
        // Find which window this stream maps to

        let stream = self.current_stream.clone();
    fn add_text_to_current_stream(&mut self, text: StyledText) {
    /// Add text to the appropriate window/tab for the current stream

    }
        }
            }
                }
                    }
                        }
                            tracing::warn!("Failed to play sound '{}': {}", sound_file, e);
                        if let Err(e) = sound_player.play_from_sounds_dir(sound_file, pattern.sound_volume) {
                        // Play the sound
                    if let Some(ref sound_file) = pattern.sound {
                if matches {

                };
                    }
                        false
                    } else {
                        regex.is_match(text)
                    if let Ok(regex) = regex::Regex::new(&pattern.pattern) {
                    // Regex parse
                } else {
                    pattern.pattern.split('|').any(|p| text.contains(p.trim()))
                    // Fast parse: check if any of the pipe-separated patterns are in the text
                let matches = if pattern.fast_parse {

                }
                    continue;
                if pattern.sound.is_none() {
                // Skip if no sound configured for this pattern
            for (_name, pattern) in &self.config.highlights {
        if let Some(ref sound_player) = self.sound_player {
    fn check_sound_triggers(&mut self, text: &str) {
    /// Check if text matches any highlight patterns with sounds and play them

    }
            .expect("Window must exist")
            .get_window(&window_name)
        self.window_manager
        // Then get the window

        };
                .unwrap_or_else(|| "main".to_string())
                .cloned()
                .get(stream)
                .stream_map
            self.window_manager
            let stream = &self.current_stream;
        let window_name = {
        // First, determine which window name to use
    fn get_current_window(&mut self) -> &mut Widget {
    /// Get the window for the current stream, falling back to main window

    }
        Ok(())

        }
            }
                self.add_system_message(&message);
                tracing::warn!("{}", message);

                };
                    )
                        current_w, current_h, layout_w, layout_h
                        "Terminal {}x{} larger than layout {}x{} - use .resize to expand layout.",
                    format!(
                } else {
                    )
                        current_w, current_h, layout_w, layout_h
                        "⚠️  Terminal {}x{} smaller than layout {}x{} - some widgets hidden. Use .resize to adapt.",
                    format!(
                let message = if current_w < layout_w || current_h < layout_h {
            if current_w != layout_w || current_h != layout_h {
            // Check if terminal size doesn't match layout

                .context("Failed to get terminal size")?;
            let (current_w, current_h) = crossterm::terminal::size()
            // Get current terminal size
        if let (Some(layout_w), Some(layout_h)) = (self.layout.terminal_width, self.layout.terminal_height) {
        // Check if layout has designed terminal size
    pub fn check_and_auto_resize(&mut self) -> Result<()> {
    /// Check if layout fits terminal and warn if not

    }
        })
            shown_bounds_warning: false,  // Haven't shown warning yet
            resize_debouncer: ResizeDebouncer::new(300),  // 300ms debounce for terminal resize
            baseline_layout: Some(baseline_layout),  // Store baseline layout for resize calculations
            baseline_snapshot: None,  // No baseline snapshot initially (will be set after layout load)
            spell_color_form: None,  // Spell color form not shown initially
            spell_color_browser: None,  // Spell color browser not shown initially
            color_form: None,  // Color form not shown initially
            color_palette_browser: None,  // Color palette browser not shown initially
            keybind_browser: None,  // Keybind browser not shown initially
            highlight_browser: None,  // Highlight browser not shown initially
            settings_editor: None,  // Settings editor not shown initially
            window_editor: crate::ui::WindowEditor::new(),  // Initialize window editor
            drag_state: None,  // No drag operation initially
            menu_categories: HashMap::new(),  // No cached categories initially
            last_link_click_pos: None,  // No last click position initially
            nested_submenu: None,  // No nested submenu initially
            submenu: None,  // No submenu initially
            popup_menu: None,  // No popup menu initially
            pending_menu_requests: HashMap::new(),  // No pending requests initially
            menu_request_counter: 0,  // Start counter at 0
            cmdlist,  // Command list (may be None if failed to load)
            selection_drag_start: None,  // No drag initially
            selection_state: None,  // No selection initially
            keybind_form: None,  // No form shown initially
            highlight_form: None,  // No form shown initially
            sound_player,  // Sound player (may be None if initialization failed)
            stream_buffer: String::new(),  // Initialize empty stream buffer
            show_perf_stats: false,  // Hidden by default
            perf_stats: PerformanceStats::new(),  // Initialize performance stats
            input_mode: InputMode::Normal,  // Start in normal mode
            move_state: None, // No active move initially
            resize_state: None, // No active resize initially
            focused_window_index: 0, // Start with first window focused
            server_time_offset: 0, // No offset until first prompt
            skip_next_prompt: false,
            discard_current_stream: false,
            current_stream: "main".to_string(),
            prompt_shown: false,
            running: true,
            layout,
            config,
            keybind_map,
            parser: XmlParser::with_presets(presets, config.event_patterns.clone()),
            search_input: CommandInput::new(50),  // Smaller history for search
            command_input,
            ),
                config.ui.countdown_icon.clone(),
                config.highlights.clone(),
                window_configs,
            window_manager: WindowManager::new(
        Ok(Self {

        };
            }
                None
                tracing::warn!("Failed to load command list: {}. Context menus will not be available.", e);
            Err(e) => {
            }
                Some(list)
                tracing::info!("Command list loaded successfully");
            Ok(list) => {
        let cmdlist = match CmdList::load() {
        // Load command list for context menus

        }
            tracing::warn!("Failed to load command history: {}", e);
        if let Err(e) = command_input.load_history(config.character.as_deref()) {
        // Load command history

        };
            }
                None
                tracing::warn!("Failed to initialize sound player: {}", e);
            Err(e) => {
            }
                Some(player)
                }
                    tracing::warn!("Failed to create sounds directory: {}", e);
                if let Err(e) = crate::sound::ensure_sounds_directory() {
                // Ensure sounds directory exists
            Ok(player) => {
        ) {
            config.sound.cooldown_ms,
            config.sound.volume,
            config.sound.enabled,
        let sound_player = match SoundPlayer::new(
        // Initialize sound player

        command_input.set_background_color(cmd_window.background_color.clone());
        }
            command_input.set_title(title.clone());
        if let Some(ref title) = cmd_window.title {
        );
            cmd_window.border_color.clone(),
            cmd_window.border_style.clone(),
            cmd_window.show_border,
        command_input.set_border_config(
        command_input.set_min_command_length(config.ui.min_command_length);
        let mut command_input = CommandInput::new(100);
        // Create command input with config from WindowDef

            .expect("command_input must exist in windows array (layout migration should ensure this)");
            .find(|w| w.widget_type == "command_input")
        let cmd_window = layout.windows.iter()
        // Find command_input from windows array

        debug!("Loaded {} keybindings", keybind_map.len());

        }
            }
                tracing::warn!("Could not parse key string: {}", key_str);
            } else {
                }
                    tracing::warn!("Invalid keybind: {} -> {:?}", key_str, keybind_action);
                } else {
                    keybind_map.insert((key_code, modifiers), action);
                if let Some(action) = action {

                };
                    }
                        Some(KeyAction::SendMacro(macro_action.macro_text.clone()))
                    KeyBindAction::Macro(macro_action) => {
                    }
                        KeyAction::from_str(action_str)
                    KeyBindAction::Action(action_str) => {
                let action = match keybind_action {
            if let Some((key_code, modifiers)) = parse_key_string(key_str) {
        for (key_str, keybind_action) in &config.keybinds {
        let mut keybind_map = HashMap::new();
        // Build keybind map

        }
                wc.name, wc.widget_type, wc.streams, wc.row, wc.col, wc.rows, wc.cols, wc.buffer_size);
            debug!("  '{}' ({}) - streams: {:?}, pos: ({},{}) size: ({}x{}), buffer: {}",
        for wc in &window_configs {
        debug!("Creating {} windows:", window_configs.len());

            .collect();
            })
                scar3_color: w.scar3_color.clone(),
                scar2_color: w.scar2_color.clone(),
                scar1_color: w.scar1_color.clone(),
                injury3_color: w.injury3_color.clone(),
                injury2_color: w.injury2_color.clone(),
                injury1_color: w.injury1_color.clone(),
                injury_default_color: w.injury_default_color.clone(),
                numbers_only: Some(w.numbers_only),
                compass_inactive_color: w.compass_inactive_color.clone(),
                compass_active_color: w.compass_active_color.clone(),
                hand_icon: w.hand_icon.clone(),
                tab_unread_prefix: w.tab_unread_prefix.clone(),
                tab_unread_color: w.tab_unread_color.clone(),
                tab_inactive_color: w.tab_inactive_color.clone(),
                tab_active_color: w.tab_active_color.clone(),
                tab_bar_position: w.tab_bar_position.clone(),
                tabs: w.tabs.clone(),
                effect_category: w.effect_category.clone(),
                visible_count: w.visible_count,
                dashboard_hide_inactive: w.dashboard_hide_inactive,
                dashboard_spacing: w.dashboard_spacing,
                dashboard_indicators: w.dashboard_indicators.clone(),
                dashboard_layout: w.dashboard_layout.clone(),
                indicator_colors: w.indicator_colors.clone(),
                countdown_icon: countdown_icon.clone(),
                transparent_background: w.transparent_background,
                text_color: w.text_color.clone(),
                bar_background_color: w.bar_background_color.clone(),
                bar_color: w.bar_color.clone(),
                background_color: w.background_color.clone(),
                content_align: w.content_align.clone(),
                title: w.title.clone(),
                border_sides: w.border_sides.clone(),
                border_color: w.border_color.clone(),
                border_style: w.border_style.clone(),
                show_border: w.show_border,
                buffer_size: w.buffer_size,
                cols: w.cols,
                rows: w.rows,
                col: w.col,
                row: w.row,
                streams: w.streams.clone(),
                widget_type: w.widget_type.clone(),
                name: w.name.clone(),
            .map(|w| WindowConfig {
            .iter()
            .windows
        let window_configs: Vec<WindowConfig> = layout
        let countdown_icon = Some(config.ui.countdown_icon.clone());
        // Convert window configs from layout

        }
            debug!("  '{}' -> fg: {}, bg: {}", pc.character, fg, bg);
            let bg = pc.bg.as_ref().map(|s| s.as_str()).unwrap_or("none");
            let fg = pc.fg.as_ref().or(pc.color.as_ref()).map(|s| s.as_str()).unwrap_or("none");
        for pc in &config.ui.prompt_colors {
        debug!("Loaded {} prompt color mappings:", config.ui.prompt_colors.len());

            .collect();
            .map(|(id, p)| (id.clone(), p.fg.clone(), p.bg.clone()))
            .iter()
            .presets
        let presets: Vec<(String, Option<String>, Option<String>)> = config
        // Convert config presets to parser format

        let baseline_layout = layout.clone();
        // Clone layout as baseline for resize calculations (before any modifications)

        info!("Loaded layout with {} windows", layout.windows.len());
        let mut layout = Layout::load_with_terminal_size(config.character.as_deref(), terminal_size)?;
        // Priority: auto_<character>.toml → <character>.toml → layout mapping → default.toml → embedded default

        let terminal_size = crossterm::terminal::size().ok();
        // Get terminal size for layout auto-selection
        // Load layout (separate from config)
    pub fn new(config: Config) -> Result<Self> {
impl App {

}
    Right,
    Left,
    Bottom,
    Top,
enum ResizeEdge {
#[derive(Debug, Clone, Copy)]

}
    start_window_pos: (u16, u16), // (col, row) original window position
    start_mouse_pos: (u16, u16), // (col, row) where drag started
    window_index: usize,
struct MoveState {
#[derive(Debug, Clone)]

}
    start_mouse_pos: (u16, u16), // (col, row) where drag started
    edge: ResizeEdge,
    window_index: usize,
struct ResizeState {
#[derive(Debug, Clone)]

}
    noun: String,
    exist_id: String,
struct PendingMenuRequest {
#[derive(Debug, Clone)]
/// Pending menu request information

}
    source_window: String,           // Window where drag started
    current_pos: (u16, u16),         // Current mouse position (col, row)
    start_pos: (u16, u16),           // Where drag started (col, row)
    link_data: crate::ui::LinkData,  // What we're dragging
struct DragState {
#[derive(Debug, Clone)]
/// Drag and drop state

}
    shown_bounds_warning: bool,  // Track if we've shown the out-of-bounds warning
    resize_debouncer: ResizeDebouncer,  // Debouncer for terminal resize events (300ms default)
    baseline_layout: Option<Layout>,  // Baseline layout (original widget positions/sizes) for proportional resizing
    baseline_snapshot: Option<(u16, u16)>,  // Baseline terminal size (width, height) for proportional resizing
    spell_color_form: Option<crate::ui::SpellColorFormWidget>,  // Spell color editor form (None when not shown)
    spell_color_browser: Option<crate::ui::SpellColorBrowser>,  // Spell color browser (None when not shown)
    color_form: Option<crate::ui::ColorForm>,  // Color editor form (None when not shown)
    color_palette_browser: Option<crate::ui::ColorPaletteBrowser>,  // Color palette browser (None when not shown)
    keybind_browser: Option<crate::ui::KeybindBrowser>,  // Keybind browser (None when not shown)
    highlight_browser: Option<crate::ui::HighlightBrowser>,  // Highlight browser (None when not shown)
    settings_editor: Option<crate::ui::SettingsEditor>,  // Settings editor (None when not shown)
    window_editor: crate::ui::WindowEditor,  // Window configuration editor
    drag_state: Option<DragState>,  // Active drag operation (None when not dragging)
    menu_categories: HashMap<String, Vec<crate::ui::MenuItem>>,  // Cached categories for submenus
    last_link_click_pos: Option<(u16, u16)>,  // Position of last link click (for menu positioning)
    nested_submenu: Option<crate::ui::PopupMenu>,  // Active nested submenu (third level)
    submenu: Option<crate::ui::PopupMenu>,  // Active submenu (None when no submenu shown)
    popup_menu: Option<crate::ui::PopupMenu>,  // Active main popup menu (None when no menu shown)
    pending_menu_requests: HashMap<String, PendingMenuRequest>,  // counter -> (exist_id, noun)
    menu_request_counter: u32,  // Counter for menu request correlation IDs
    cmdlist: Option<CmdList>,  // Command list for context menus (None if failed to load)
    selection_drag_start: Option<(u16, u16)>,  // Mouse position when drag started (for detecting drag vs click)
    selection_state: Option<SelectionState>,  // Current text selection (None when no selection)
    keybind_form: Option<crate::ui::KeybindFormWidget>,  // Keybind form (None when not shown)
    highlight_form: Option<crate::ui::HighlightFormWidget>,  // Highlight form (None when not shown)
    sound_player: Option<SoundPlayer>,  // Sound player (None if initialization failed)
    stream_buffer: String,  // Buffer for accumulating stream text (used for combat/playerlist)
    show_perf_stats: bool,  // Whether to show performance stats window
    perf_stats: PerformanceStats,  // Performance statistics
    keybind_map: HashMap<(KeyCode, KeyModifiers), KeyAction>,  // Parsed keybindings
    input_mode: InputMode,  // Track current input mode
    move_state: Option<MoveState>, // Track active window move operation
    resize_state: Option<ResizeState>, // Track active resize operation
    focused_window_index: usize, // Index of currently focused window for scrolling
    server_time_offset: i64, // Offset between server time and local time (server_time - local_time) - used for countdown calculations to avoid clock drift
    skip_next_prompt: bool, // Skip the next prompt (after returning from a non-main stream)
    discard_current_stream: bool, // If true, discard text because no window exists for current stream
    current_stream: String, // Track which stream we're currently writing to
    prompt_shown: bool, // Track if we've shown a prompt since last real text
    running: bool,
    parser: XmlParser,
    search_input: CommandInput,  // Separate input for search
    command_input: CommandInput,
    window_manager: WindowManager,
    layout: Layout,
    config: Config,
pub struct App {

}
    WindowEditor,  // Window configuration editor
    SpellColorForm,  // Spell color editor form
    SpellColorBrowser,  // Spell color browser
    ColorForm,  // Color palette editor form
    ColorBrowserFilter,  // Color palette browser filter input
    ColorPaletteBrowser,  // Color palette browser
    KeybindBrowser,  // Keybind browser
    HighlightBrowser,  // Highlight browser
    SettingsEditor,  // Settings editor form
    KeybindForm,  // Keybind management form
    HighlightForm,  // Highlight management form
    Search,   // Search mode (typing search query)
    Command,  // Command input mode (typing a command)
    Normal,   // Normal text input to command window
enum InputMode {
#[derive(Debug, Clone, Copy, PartialEq)]

}
    }
        None
        }
            }
                return Some(size);
                self.last_resize_time = now;
            if let Some(size) = self.pending_size.take() {
        if elapsed >= self.debounce_duration {

        let elapsed = now.duration_since(self.last_resize_time);
        let now = std::time::Instant::now();
    fn check_pending(&mut self) -> Option<(u16, u16)> {
    /// Check if there's a pending resize that should be processed

    }
        }
            None
            self.pending_size = Some((width, height));
            // Still within debounce period, store pending size
        } else {
            Some((width, height))
            self.pending_size = None;
            self.last_resize_time = now;
            // Enough time has passed, process this resize
        if elapsed >= self.debounce_duration {

        let elapsed = now.duration_since(self.last_resize_time);
        let now = std::time::Instant::now();
    fn check_resize(&mut self, width: u16, height: u16) -> Option<(u16, u16)> {
    /// Returns Some(size) if the resize should be processed now, None if it should be debounced
    /// Check if a resize event should be processed or debounced

    }
        }
            pending_size: None,
            debounce_duration: std::time::Duration::from_millis(debounce_ms),
            last_resize_time: std::time::Instant::now(),
        Self {
    fn new(debounce_ms: u64) -> Self {
impl ResizeDebouncer {

}
    pending_size: Option<(u16, u16)>, // (width, height)
    debounce_duration: std::time::Duration,
    last_resize_time: std::time::Instant,
struct ResizeDebouncer {
/// Debouncer for terminal resize events to prevent excessive layout recalculations

use rand::Rng;
use tracing::{debug, info};
use tokio::sync::mpsc;
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::io;
use std::collections::HashMap;
};
    Terminal,
    style::{Color, Modifier, Style},
    layout::Rect,
    buffer::Buffer,
    backend::CrosstermBackend,
use ratatui::{
};
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
    execute,
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind, KeyModifiers},
use crossterm::{
use anyhow::{Context, Result};
use crate::ui::{CommandInput, PerformanceStatsWidget, SpanType, StyledText, UiLayout, Widget, WindowManager, WindowConfig};
use crate::sound::SoundPlayer;
use crate::selection::SelectionState;
use crate::performance::PerformanceStats;
use crate::parser::{ParsedElement, XmlParser};
use crate::network::{LichConnection, ServerMessage};
use crate::config::{Config, KeyAction, KeyBindAction, Layout, parse_key_string};